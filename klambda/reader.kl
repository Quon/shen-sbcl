"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun read-file-as-bytelist (V2163) (let Stream (open V2163 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V2167 V2168 V2169) (cond ((= -1 V2168) V2169) (true (shen.read-file-as-bytelist-help V2167 (read-byte V2167) (cons V2168 V2169)))))

(defun read-file-as-string (V2171) (let Stream (open V2171 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V2175 V2176 V2177) (cond ((= -1 V2176) (do (close V2175) V2177)) (true (shen.rfas-h V2175 (read-byte V2175) (cn V2177 (n->string V2176))))))

(defun input (V2179) (eval-kl (read V2179)))

(defun input+ (V2182 V2183) (let Mono? (shen.monotype V2182) (let Input (read V2183) (if (= false (shen.typecheck Input (shen.demodulate V2182))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V2182 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V2185) (cond ((cons? V2185) (map (lambda Z (shen.monotype Z)) V2185)) (true (if (variable? V2185) (simple-error (cn "input+ expects a monotype: not " (shen.app V2185 "
" shen.a))) V2185))))

(defun read (V2187) (hd (shen.read-loop V2187 (read-byte V2187) ())))

(defun it () (value shen.*it*))

(defun shen.read-loop (V2195 V2196 V2197) (cond ((= 94 V2196) (simple-error "read aborted")) ((= -1 V2196) (if (empty? V2197) (simple-error "error: empty stream") (compile (lambda X (shen.<st_input> X)) V2197 (lambda E E)))) ((shen.terminator? V2196) (let AllBytes (append V2197 (cons V2196 ())) (let It (shen.record-it AllBytes) (let Read (compile (lambda X (shen.<st_input> X)) AllBytes (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V2195 (read-byte V2195) AllBytes) Read))))) (true (shen.read-loop V2195 (read-byte V2195) (append V2197 (cons V2196 ()))))))

(defun shen.terminator? (V2199) (element? V2199 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V2201) (shen.lineread-loop (read-byte V2201) () V2201))

(defun shen.lineread-loop (V2206 V2207 V2208) (cond ((= -1 V2206) (if (empty? V2207) (simple-error "empty stream") (compile (lambda X (shen.<st_input> X)) V2207 (lambda E E)))) ((= V2206 (shen.hat)) (simple-error "line read aborted")) ((element? V2206 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X (shen.<st_input> X)) V2207 (lambda E shen.nextline)) (let It (shen.record-it V2207) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-byte V2208) (append V2207 (cons V2206 ())) V2208) Line)))) (true (shen.lineread-loop (read-byte V2208) (append V2207 (cons V2206 ())) V2208))))

(defun shen.record-it (V2210) (let TrimLeft (shen.trim-whitespace V2210) (let TrimRight (shen.trim-whitespace (reverse TrimLeft)) (let Trimmed (reverse TrimRight) (shen.record-it-h Trimmed)))))

(defun shen.trim-whitespace (V2212) (cond ((and (cons? V2212) (element? (hd V2212) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen.trim-whitespace (tl V2212))) (true V2212)))

(defun shen.record-it-h (V2214) (do (set shen.*it* (shen.cn-all (map (lambda X (n->string X)) V2214))) V2214))

(defun shen.cn-all (V2216) (cond ((= () V2216) "") ((cons? V2216) (cn (hd V2216) (shen.cn-all (tl V2216)))) (true (shen.f_error shen.cn-all))))

(defun read-file (V2218) (let Bytelist (read-file-as-bytelist V2218) (compile (lambda X (shen.<st_input> X)) Bytelist (lambda X (shen.read-error X)))))

(defun read-from-string (V2220) (let Ns (map (lambda X (string->n X)) (explode V2220)) (compile (lambda X (shen.<st_input> X)) Ns (lambda X (shen.read-error X)))))

(defun shen.read-error (V2228) (cond ((and (cons? V2228) (and (cons? (hd V2228)) (and (cons? (tl V2228)) (= () (tl (tl V2228)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V2228)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V2235 V2236) (cond ((= () V2236) "") ((= 0 V2235) "") ((cons? V2236) (cn (n->string (hd V2236)) (shen.compress-50 (- V2235 1) (tl V2236)))) (true (shen.f_error shen.compress-50))))

(defun shen.<st_input> (V2238) (let YaccParse (let Parse_shen.<lsb> (shen.<lsb> V2238) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lrb> (shen.<lrb> V2238) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lcurly> (shen.<lcurly> V2238) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<rcurly> (shen.<rcurly> V2238) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<bar> (shen.<bar> V2238) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<semicolon> (shen.<semicolon> V2238) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2238) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2238) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2238) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comma> (shen.<comma> V2238) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2238) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<atom> (shen.<atom> V2238) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<whitespaces> (shen.<whitespaces> V2238) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2238) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<lsb> (V2240) (if (and (cons? (hd V2240)) (= 91 (hd (hd V2240)))) (shen.pair (hd (shen.pair (tl (hd V2240)) (shen.hdtl V2240))) shen.skip) (fail)))

(defun shen.<rsb> (V2242) (if (and (cons? (hd V2242)) (= 93 (hd (hd V2242)))) (shen.pair (hd (shen.pair (tl (hd V2242)) (shen.hdtl V2242))) shen.skip) (fail)))

(defun shen.<lcurly> (V2244) (if (and (cons? (hd V2244)) (= 123 (hd (hd V2244)))) (shen.pair (hd (shen.pair (tl (hd V2244)) (shen.hdtl V2244))) shen.skip) (fail)))

(defun shen.<rcurly> (V2246) (if (and (cons? (hd V2246)) (= 125 (hd (hd V2246)))) (shen.pair (hd (shen.pair (tl (hd V2246)) (shen.hdtl V2246))) shen.skip) (fail)))

(defun shen.<bar> (V2248) (if (and (cons? (hd V2248)) (= 124 (hd (hd V2248)))) (shen.pair (hd (shen.pair (tl (hd V2248)) (shen.hdtl V2248))) shen.skip) (fail)))

(defun shen.<semicolon> (V2250) (if (and (cons? (hd V2250)) (= 59 (hd (hd V2250)))) (shen.pair (hd (shen.pair (tl (hd V2250)) (shen.hdtl V2250))) shen.skip) (fail)))

(defun shen.<colon> (V2252) (if (and (cons? (hd V2252)) (= 58 (hd (hd V2252)))) (shen.pair (hd (shen.pair (tl (hd V2252)) (shen.hdtl V2252))) shen.skip) (fail)))

(defun shen.<comma> (V2254) (if (and (cons? (hd V2254)) (= 44 (hd (hd V2254)))) (shen.pair (hd (shen.pair (tl (hd V2254)) (shen.hdtl V2254))) shen.skip) (fail)))

(defun shen.<equal> (V2256) (if (and (cons? (hd V2256)) (= 61 (hd (hd V2256)))) (shen.pair (hd (shen.pair (tl (hd V2256)) (shen.hdtl V2256))) shen.skip) (fail)))

(defun shen.<minus> (V2258) (if (and (cons? (hd V2258)) (= 45 (hd (hd V2258)))) (shen.pair (hd (shen.pair (tl (hd V2258)) (shen.hdtl V2258))) shen.skip) (fail)))

(defun shen.<lrb> (V2260) (if (and (cons? (hd V2260)) (= 40 (hd (hd V2260)))) (shen.pair (hd (shen.pair (tl (hd V2260)) (shen.hdtl V2260))) shen.skip) (fail)))

(defun shen.<rrb> (V2262) (if (and (cons? (hd V2262)) (= 41 (hd (hd V2262)))) (shen.pair (hd (shen.pair (tl (hd V2262)) (shen.hdtl V2262))) shen.skip) (fail)))

(defun shen.<atom> (V2264) (let YaccParse (let Parse_shen.<str> (shen.<str> V2264) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<number> (shen.<number> V2264) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<sym> (shen.<sym> V2264) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) YaccParse)) YaccParse)))

(defun shen.control-chars (V2266) (cond ((= () V2266) "") ((and (cons? V2266) (and (= "c" (hd V2266)) (and (cons? (tl V2266)) (= "#" (hd (tl V2266)))))) (let CodePoint (shen.code-point (tl (tl V2266))) (let AfterCodePoint (shen.after-codepoint (tl (tl V2266))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V2266) (@s (hd V2266) (shen.control-chars (tl V2266)))) (true (shen.f_error shen.control-chars))))

(defun shen.code-point (V2270) (cond ((and (cons? V2270) (= ";" (hd V2270))) "") ((and (cons? V2270) (element? (hd V2270) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V2270) (shen.code-point (tl V2270)))) (true (simple-error (cn "code point parse error " (shen.app V2270 "
" shen.a))))))

(defun shen.after-codepoint (V2276) (cond ((= () V2276) ()) ((and (cons? V2276) (= ";" (hd V2276))) (tl V2276)) ((cons? V2276) (shen.after-codepoint (tl V2276))) (true (shen.f_error shen.after-codepoint))))

(defun shen.decimalise (V2278) (shen.pre (reverse (shen.digits->integers V2278)) 0))

(defun shen.digits->integers (V2284) (cond ((and (cons? V2284) (= "0" (hd V2284))) (cons 0 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "1" (hd V2284))) (cons 1 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "2" (hd V2284))) (cons 2 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "3" (hd V2284))) (cons 3 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "4" (hd V2284))) (cons 4 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "5" (hd V2284))) (cons 5 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "6" (hd V2284))) (cons 6 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "7" (hd V2284))) (cons 7 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "8" (hd V2284))) (cons 8 (shen.digits->integers (tl V2284)))) ((and (cons? V2284) (= "9" (hd V2284))) (cons 9 (shen.digits->integers (tl V2284)))) (true ())))

(defun shen.<sym> (V2286) (let Parse_shen.<alpha> (shen.<alpha> V2286) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))))

(defun shen.<alphanums> (V2288) (let YaccParse (let Parse_shen.<alphanum> (shen.<alphanum> V2288) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2288) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) YaccParse)))

(defun shen.<alphanum> (V2290) (let YaccParse (let Parse_shen.<alpha> (shen.<alpha> V2290) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<num> (shen.<num> V2290) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) YaccParse)))

(defun shen.<num> (V2292) (if (cons? (hd V2292)) (let Parse_Byte (hd (hd V2292)) (if (shen.numbyte? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V2292)) (shen.hdtl V2292))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.numbyte? (V2298) (cond ((= 48 V2298) true) ((= 49 V2298) true) ((= 50 V2298) true) ((= 51 V2298) true) ((= 52 V2298) true) ((= 53 V2298) true) ((= 54 V2298) true) ((= 55 V2298) true) ((= 56 V2298) true) ((= 57 V2298) true) (true false)))

(defun shen.<alpha> (V2300) (if (cons? (hd V2300)) (let Parse_Byte (hd (hd V2300)) (if (shen.symbol-code? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V2300)) (shen.hdtl V2300))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.symbol-code? (V2302) (or (= V2302 126) (or (and (> V2302 94) (< V2302 123)) (or (and (> V2302 59) (< V2302 91)) (or (and (> V2302 41) (and (< V2302 58) (not (= V2302 44)))) (or (and (> V2302 34) (< V2302 40)) (= V2302 33)))))))

(defun shen.<str> (V2304) (let Parse_shen.<dbq> (shen.<dbq> V2304) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))))

(defun shen.<dbq> (V2306) (if (cons? (hd V2306)) (let Parse_Byte (hd (hd V2306)) (if (= Parse_Byte 34) (shen.pair (hd (shen.pair (tl (hd V2306)) (shen.hdtl V2306))) Parse_Byte) (fail))) (fail)))

(defun shen.<strcontents> (V2308) (let YaccParse (let Parse_shen.<strc> (shen.<strc> V2308) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2308) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<byte> (V2310) (if (cons? (hd V2310)) (let Parse_Byte (hd (hd V2310)) (shen.pair (hd (shen.pair (tl (hd V2310)) (shen.hdtl V2310))) (n->string Parse_Byte))) (fail)))

(defun shen.<strc> (V2312) (if (cons? (hd V2312)) (let Parse_Byte (hd (hd V2312)) (if (not (= Parse_Byte 34)) (shen.pair (hd (shen.pair (tl (hd V2312)) (shen.hdtl V2312))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.<number> (V2314) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2314) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<plus> (shen.<plus> V2314) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2314) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2314) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2314) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2314) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<E> (V2316) (if (and (cons? (hd V2316)) (= 101 (hd (hd V2316)))) (shen.pair (hd (shen.pair (tl (hd V2316)) (shen.hdtl V2316))) shen.skip) (fail)))

(defun shen.<log10> (V2318) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2318) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2318) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)))

(defun shen.<plus> (V2320) (if (cons? (hd V2320)) (let Parse_Byte (hd (hd V2320)) (if (= Parse_Byte 43) (shen.pair (hd (shen.pair (tl (hd V2320)) (shen.hdtl V2320))) Parse_Byte) (fail))) (fail)))

(defun shen.<stop> (V2322) (if (cons? (hd V2322)) (let Parse_Byte (hd (hd V2322)) (if (= Parse_Byte 46) (shen.pair (hd (shen.pair (tl (hd V2322)) (shen.hdtl V2322))) Parse_Byte) (fail))) (fail)))

(defun shen.<predigits> (V2324) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2324) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2324) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<postdigits> (V2326) (let Parse_shen.<digits> (shen.<digits> V2326) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))))

(defun shen.<digits> (V2328) (let YaccParse (let Parse_shen.<digit> (shen.<digit> V2328) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digit> (shen.<digit> V2328) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) YaccParse)))

(defun shen.<digit> (V2330) (if (cons? (hd V2330)) (let Parse_X (hd (hd V2330)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V2330)) (shen.hdtl V2330))) (shen.byte->digit Parse_X)) (fail))) (fail)))

(defun shen.byte->digit (V2332) (cond ((= 48 V2332) 0) ((= 49 V2332) 1) ((= 50 V2332) 2) ((= 51 V2332) 3) ((= 52 V2332) 4) ((= 53 V2332) 5) ((= 54 V2332) 6) ((= 55 V2332) 7) ((= 56 V2332) 8) ((= 57 V2332) 9) (true (shen.f_error shen.byte->digit))))

(defun shen.pre (V2337 V2338) (cond ((= () V2337) 0) ((cons? V2337) (+ (* (shen.expt 10 V2338) (hd V2337)) (shen.pre (tl V2337) (+ V2338 1)))) (true (shen.f_error shen.pre))))

(defun shen.post (V2343 V2344) (cond ((= () V2343) 0) ((cons? V2343) (+ (* (shen.expt 10 (- 0 V2344)) (hd V2343)) (shen.post (tl V2343) (+ V2344 1)))) (true (shen.f_error shen.post))))

(defun shen.expt (V2349 V2350) (cond ((= 0 V2350) 1) ((> V2350 0) (* V2349 (shen.expt V2349 (- V2350 1)))) (true (* 1.0 (/ (shen.expt V2349 (+ V2350 1)) V2349)))))

(defun shen.<st_input1> (V2352) (let Parse_shen.<st_input> (shen.<st_input> V2352) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<st_input2> (V2354) (let Parse_shen.<st_input> (shen.<st_input> V2354) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<comment> (V2356) (let YaccParse (let Parse_shen.<singleline> (shen.<singleline> V2356) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<multiline> (shen.<multiline> V2356) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) YaccParse)))

(defun shen.<singleline> (V2358) (let Parse_shen.<backslash> (shen.<backslash> V2358) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))))

(defun shen.<backslash> (V2360) (if (and (cons? (hd V2360)) (= 92 (hd (hd V2360)))) (shen.pair (hd (shen.pair (tl (hd V2360)) (shen.hdtl V2360))) shen.skip) (fail)))

(defun shen.<anysingle> (V2362) (let YaccParse (let Parse_shen.<non-return> (shen.<non-return> V2362) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2362) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) YaccParse)))

(defun shen.<non-return> (V2364) (if (cons? (hd V2364)) (let Parse_X (hd (hd V2364)) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (tl (hd V2364)) (shen.hdtl V2364))) shen.skip) (fail))) (fail)))

(defun shen.<return> (V2366) (if (cons? (hd V2366)) (let Parse_X (hd (hd V2366)) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (tl (hd V2366)) (shen.hdtl V2366))) shen.skip) (fail))) (fail)))

(defun shen.<multiline> (V2368) (let Parse_shen.<backslash> (shen.<backslash> V2368) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))))

(defun shen.<times> (V2370) (if (and (cons? (hd V2370)) (= 42 (hd (hd V2370)))) (shen.pair (hd (shen.pair (tl (hd V2370)) (shen.hdtl V2370))) shen.skip) (fail)))

(defun shen.<anymulti> (V2372) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2372) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<times> (shen.<times> V2372) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (if (cons? (hd V2372)) (let Parse_X (hd (hd V2372)) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (tl (hd V2372)) (shen.hdtl V2372))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) YaccParse)) YaccParse)))

(defun shen.<whitespaces> (V2374) (let YaccParse (let Parse_shen.<whitespace> (shen.<whitespace> V2374) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<whitespace> (shen.<whitespace> V2374) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) YaccParse)))

(defun shen.<whitespace> (V2376) (if (cons? (hd V2376)) (let Parse_X (hd (hd V2376)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V2376)) (shen.hdtl V2376))) shen.skip) (fail))) (fail)))

(defun shen.cons_form (V2378) (cond ((= () V2378) ()) ((and (cons? V2378) (and (cons? (tl V2378)) (and (cons? (tl (tl V2378))) (and (= () (tl (tl (tl V2378)))) (= (hd (tl V2378)) bar!))))) (cons cons (cons (hd V2378) (tl (tl V2378))))) ((cons? V2378) (cons cons (cons (hd V2378) (cons (shen.cons_form (tl V2378)) ())))) (true (shen.f_error shen.cons_form))))

(defun shen.package-macro (V2383 V2384) (cond ((and (cons? V2383) (and (= $ (hd V2383)) (and (cons? (tl V2383)) (= () (tl (tl V2383)))))) (append (explode (hd (tl V2383))) V2384)) ((and (cons? V2383) (and (= package (hd V2383)) (and (cons? (tl V2383)) (and (= null (hd (tl V2383))) (cons? (tl (tl V2383))))))) (append (tl (tl (tl V2383))) V2384)) ((and (cons? V2383) (and (= package (hd V2383)) (and (cons? (tl V2383)) (cons? (tl (tl V2383)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V2383)))) (let External (shen.record-exceptions ListofExceptions (hd (tl V2383))) (let PackageNameDot (intern (cn (str (hd (tl V2383))) ".")) (let ExpPackageNameDot (explode PackageNameDot) (let Packaged (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V2383))) ExpPackageNameDot) (let Internal (shen.record-internal (hd (tl V2383)) (shen.internal-symbols ExpPackageNameDot Packaged)) (append Packaged V2384)))))))) (true (cons V2383 V2384))))

(defun shen.record-exceptions (V2387 V2388) (let CurrExceptions (get/or V2388 shen.external-symbols (freeze ()) (value *property-vector*)) (let AllExceptions (union V2387 CurrExceptions) (put V2388 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.record-internal (V2391 V2392) (put V2391 shen.internal-symbols (union V2392 (get/or V2391 shen.internal-symbols (freeze ()) (value *property-vector*))) (value *property-vector*)))

(defun shen.internal-symbols (V2403 V2404) (cond ((and (symbol? V2404) (shen.prefix? V2403 (explode V2404))) (cons V2404 ())) ((cons? V2404) (union (shen.internal-symbols V2403 (hd V2404)) (shen.internal-symbols V2403 (tl V2404)))) (true ())))

(defun shen.packageh (V2421 V2422 V2423 V2424) (cond ((cons? V2423) (cons (shen.packageh V2421 V2422 (hd V2423) V2424) (shen.packageh V2421 V2422 (tl V2423) V2424))) ((or (shen.sysfunc? V2423) (or (variable? V2423) (or (element? V2423 V2422) (or (shen.doubleunderline? V2423) (shen.singleunderline? V2423))))) V2423) ((and (symbol? V2423) (let ExplodeX (explode V2423) (and (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) ExplodeX)) (not (shen.prefix? V2424 ExplodeX))))) (concat V2421 V2423)) (true V2423)))



