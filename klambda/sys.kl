"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun thaw (V2622) (V2622))

(defun eval (V2624) (let Macroexpand (shen.walk (lambda Y (macroexpand Y)) V2624) (if (shen.packaged? Macroexpand) (map (lambda Z (shen.eval-without-macros Z)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.eval-without-macros (V2626) (eval-kl (shen.elim-def (shen.proc-input+ V2626))))

(defun shen.proc-input+ (V2628) (cond ((and (cons? V2628) (and (= input+ (hd V2628)) (and (cons? (tl V2628)) (and (cons? (tl (tl V2628))) (= () (tl (tl (tl V2628)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V2628))) (tl (tl V2628))))) ((and (cons? V2628) (and (= shen.read+ (hd V2628)) (and (cons? (tl V2628)) (and (cons? (tl (tl V2628))) (= () (tl (tl (tl V2628)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V2628))) (tl (tl V2628))))) ((cons? V2628) (map (lambda Z (shen.proc-input+ Z)) V2628)) (true V2628)))

(defun shen.elim-def (V2630) (cond ((and (cons? V2630) (and (= define (hd V2630)) (cons? (tl V2630)))) (shen->kl (hd (tl V2630)) (tl (tl V2630)))) ((and (cons? V2630) (and (= defmacro (hd V2630)) (cons? (tl V2630)))) (let Default (cons X (cons -> (cons X ()))) (let Def (shen.elim-def (cons define (cons (hd (tl V2630)) (append (tl (tl V2630)) Default)))) (let MacroAdd (shen.add-macro (hd (tl V2630))) Def)))) ((and (cons? V2630) (and (= defcc (hd V2630)) (cons? (tl V2630)))) (shen.elim-def (shen.yacc V2630))) ((cons? V2630) (map (lambda Z (shen.elim-def Z)) V2630)) (true V2630)))

(defun shen.add-macro (V2632) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V2632 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (set *macros* (cons (function V2632) (value *macros*)))))))

(defun shen.packaged? (V2640) (cond ((and (cons? V2640) (and (= package (hd V2640)) (and (cons? (tl V2640)) (cons? (tl (tl V2640)))))) true) (true false)))

(defun external (V2642) (get/or V2642 shen.external-symbols (freeze (simple-error (cn "package " (shen.app V2642 " has not been used.
" shen.a)))) (value *property-vector*)))

(defun internal (V2644) (get/or V2644 shen.internal-symbols (freeze (simple-error (cn "package " (shen.app V2644 " has not been used.
" shen.a)))) (value *property-vector*)))

(defun shen.package-contents (V2648) (cond ((and (cons? V2648) (and (= package (hd V2648)) (and (cons? (tl V2648)) (and (= null (hd (tl V2648))) (cons? (tl (tl V2648))))))) (tl (tl (tl V2648)))) ((and (cons? V2648) (and (= package (hd V2648)) (and (cons? (tl V2648)) (cons? (tl (tl V2648)))))) (shen.packageh (hd (tl V2648)) (hd (tl (tl V2648))) (tl (tl (tl V2648))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V2651 V2652) (cond ((cons? V2652) (V2651 (map (lambda Z (shen.walk V2651 Z)) V2652))) (true (V2651 V2652))))

(defun compile (V2656 V2657 V2658) (let O (V2656 (cons V2657 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V2658 O) (shen.hdtl O))))

(defun fail-if (V2661 V2662) (if (V2661 V2662) (fail) V2662))

(defun @s (V2665 V2666) (cn V2665 V2666))

(defun tc? () (value shen.*tc*))

(defun ps (V2668) (get/or V2668 shen.source (freeze (simple-error (shen.app V2668 " not found.
" shen.a))) (value *property-vector*)))

(defun stinput () (value *stinput*))

(defun <-address/or (V2672 V2673 V2674) (trap-error (<-address V2672 V2673) (lambda E (thaw V2674))))

(defun value/or (V2677 V2678) (trap-error (value V2677) (lambda E (thaw V2678))))

(defun vector (V2680) (let Vector (absvector (+ V2680 1)) (let ZeroStamp (address-> Vector 0 V2680) (let Standard (if (= V2680 0) ZeroStamp (shen.fillvector ZeroStamp 1 V2680 (fail))) Standard))))

(defun shen.fillvector (V2686 V2687 V2688 V2689) (cond ((= V2688 V2687) (address-> V2686 V2688 V2689)) (true (shen.fillvector (address-> V2686 V2687 V2689) (+ 1 V2687) V2688 V2689))))

(defun vector? (V2691) (and (absvector? V2691) (let X (<-address/or V2691 0 (freeze -1)) (and (number? X) (>= X 0)))))

(defun vector-> (V2695 V2696 V2697) (if (= V2696 0) (simple-error "cannot access 0th element of a vector
") (address-> V2695 V2696 V2697)))

(defun <-vector (V2700 V2701) (if (= V2701 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V2700 V2701) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun <-vector/or (V2705 V2706 V2707) (if (= V2706 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address/or V2705 V2706 V2707) (if (= VectorElement (fail)) (thaw V2707) VectorElement))))

(defun shen.posint? (V2709) (and (integer? V2709) (>= V2709 0)))

(defun limit (V2711) (<-address V2711 0))

(defun symbol? (V2713) (cond ((or (boolean? V2713) (or (number? V2713) (string? V2713))) false) (true (trap-error (let String (str V2713) (shen.analyse-symbol? String)) (lambda E false)))))

(defun shen.analyse-symbol? (V2715) (cond ((shen.+string? V2715) (and (shen.alpha? (pos V2715 0)) (shen.alphanums? (tlstr V2715)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V2717) (element? V2717 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V2719) (cond ((= "" V2719) true) ((shen.+string? V2719) (and (shen.alphanum? (pos V2719 0)) (shen.alphanums? (tlstr V2719)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V2721) (or (shen.alpha? V2721) (shen.digit? V2721)))

(defun shen.digit? (V2723) (element? V2723 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V2725) (cond ((or (boolean? V2725) (or (number? V2725) (string? V2725))) false) (true (trap-error (let String (str V2725) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V2727) (cond ((shen.+string? V2727) (and (shen.uppercase? (pos V2727 0)) (shen.alphanums? (tlstr V2727)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V2729) (element? V2729 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V2731) (concat V2731 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V2734 V2735) (intern (cn (str V2734) (str V2735))))

(defun @p (V2738 V2739) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V2738) (let Snd (address-> Vector 2 V2739) Vector)))))

(defun fst (V2741) (<-address V2741 1))

(defun snd (V2743) (<-address V2743 2))

(defun tuple? (V2745) (and (absvector? V2745) (= shen.tuple (<-address/or V2745 0 (freeze shen.not-tuple)))))

(defun append (V2748 V2749) (cond ((= () V2748) V2749) ((cons? V2748) (cons (hd V2748) (append (tl V2748) V2749))) (true (shen.f_error append))))

(defun @v (V2752 V2753) (let Limit (limit V2753) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V2752) (if (= Limit 0) X+NewVector (shen.@v-help V2753 1 Limit X+NewVector))))))

(defun shen.@v-help (V2759 V2760 V2761 V2762) (cond ((= V2761 V2760) (shen.copyfromvector V2759 V2762 V2761 (+ V2761 1))) (true (shen.@v-help V2759 (+ V2760 1) V2761 (shen.copyfromvector V2759 V2762 V2760 (+ V2760 1))))))

(defun shen.copyfromvector (V2767 V2768 V2769 V2770) (trap-error (vector-> V2768 V2770 (<-vector V2767 V2769)) (lambda E V2768)))

(defun hdv (V2772) (<-vector/or V2772 1 (freeze (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V2772 "
" shen.s))))))

(defun tlv (V2774) (let Limit (limit V2774) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V2774 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V2780 V2781 V2782 V2783) (cond ((= V2782 V2781) (shen.copyfromvector V2780 V2783 V2782 (- V2782 1))) (true (shen.tlv-help V2780 (+ V2781 1) V2782 (shen.copyfromvector V2780 V2783 V2781 (- V2781 1))))))

(defun assoc (V2795 V2796) (cond ((= () V2796) ()) ((and (cons? V2796) (and (cons? (hd V2796)) (= (hd (hd V2796)) V2795))) (hd V2796)) ((cons? V2796) (assoc V2795 (tl V2796))) (true (shen.f_error assoc))))

(defun boolean? (V2802) (cond ((= true V2802) true) ((= false V2802) true) (true false)))

(defun nl (V2804) (cond ((= 0 V2804) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V2804 1))))))

(defun difference (V2809 V2810) (cond ((= () V2809) ()) ((cons? V2809) (if (element? (hd V2809) V2810) (difference (tl V2809) V2810) (cons (hd V2809) (difference (tl V2809) V2810)))) (true (shen.f_error difference))))

(defun do (V2813 V2814) V2814)

(defun element? (V2826 V2827) (cond ((= () V2827) false) ((and (cons? V2827) (= (hd V2827) V2826)) true) ((cons? V2827) (element? V2826 (tl V2827))) (true (shen.f_error element?))))

(defun empty? (V2833) (cond ((= () V2833) true) (true false)))

(defun fix (V2836 V2837) (shen.fix-help V2836 V2837 (V2836 V2837)))

(defun shen.fix-help (V2848 V2849 V2850) (cond ((= V2850 V2849) V2850) (true (shen.fix-help V2848 V2850 (V2848 V2850)))))

(defun dict (V2852) (let D (absvector (+ 3 V2852)) (let Tag (address-> D 0 shen.dictionary) (let Capacity (address-> D 1 V2852) (let Count (address-> D 2 0) (let Fill (shen.fillvector D 3 (+ 2 V2852) ()) D))))))

(defun dict? (V2854) (and (absvector? V2854) (= (<-address/or V2854 0 (freeze shen.not-dictionary)) shen.dictionary)))

(defun shen.dict-capacity (V2856) (<-address V2856 1))

(defun dict-count (V2858) (<-address V2858 2))

(defun shen.dict-count-> (V2861 V2862) (address-> V2861 2 V2862))

(defun shen.<-dict-bucket (V2865 V2866) (<-address V2865 (+ 3 V2866)))

(defun shen.dict-bucket-> (V2870 V2871 V2872) (address-> V2870 (+ 3 V2871) V2872))

(defun shen.set-key-entry-value (V2879 V2880 V2881) (cond ((= () V2881) (cons (cons V2879 V2880) ())) ((and (cons? V2881) (and (cons? (hd V2881)) (= (hd (hd V2881)) V2879))) (cons (cons (hd (hd V2881)) V2880) (tl V2881))) ((cons? V2881) (cons (hd V2881) (shen.set-key-entry-value V2879 V2880 (tl V2881)))) (true (shen.f_error shen.set-key-entry-value))))

(defun shen.remove-key-entry-value (V2887 V2888) (cond ((= () V2888) ()) ((and (cons? V2888) (and (cons? (hd V2888)) (= (hd (hd V2888)) V2887))) (tl V2888)) ((cons? V2888) (cons (hd V2888) (shen.remove-key-entry-value V2887 (tl V2888)))) (true (shen.f_error shen.remove-key-entry-value))))

(defun shen.dict-update-count (V2892 V2893 V2894) (let Diff (- (length V2894) (length V2893)) (shen.dict-count-> V2892 (+ Diff (dict-count V2892)))))

(defun dict-> (V2898 V2899 V2900) (let N (hash V2899 (shen.dict-capacity V2898)) (let Bucket (shen.<-dict-bucket V2898 N) (let NewBucket (shen.set-key-entry-value V2899 V2900 Bucket) (let Change (shen.dict-bucket-> V2898 N NewBucket) (let Count (shen.dict-update-count V2898 Bucket NewBucket) V2900))))))

(defun <-dict/or (V2904 V2905 V2906) (let N (hash V2905 (shen.dict-capacity V2904)) (let Bucket (shen.<-dict-bucket V2904 N) (let Result (assoc V2905 Bucket) (if (empty? Result) (thaw V2906) (tl Result))))))

(defun <-dict (V2909 V2910) (<-dict/or V2909 V2910 (freeze (simple-error "value not found
"))))

(defun dict-rm (V2913 V2914) (let N (hash V2914 (shen.dict-capacity V2913)) (let Bucket (shen.<-dict-bucket V2913 N) (let NewBucket (shen.remove-key-entry-value V2914 Bucket) (let Change (shen.dict-bucket-> V2913 N NewBucket) (let Count (shen.dict-update-count V2913 Bucket NewBucket) V2914))))))

(defun dict-fold (V2918 V2919 V2920) (let Limit (shen.dict-capacity V2919) (shen.dict-fold-h V2918 V2919 V2920 0 Limit)))

(defun shen.dict-fold-h (V2927 V2928 V2929 V2930 V2931) (cond ((= V2931 V2930) V2929) (true (let B (shen.<-dict-bucket V2928 V2930) (let Acc (shen.bucket-fold V2927 B V2929) (shen.dict-fold-h V2927 V2928 Acc (+ 1 V2930) V2931))))))

(defun shen.bucket-fold (V2935 V2936 V2937) (cond ((= () V2936) V2937) ((and (cons? V2936) (cons? (hd V2936))) (V2935 (hd (hd V2936)) (tl (hd V2936)) (fold-right V2935 (tl V2936) V2937))) (true (shen.f_error shen.bucket-fold))))

(defun dict-keys (V2939) (dict-fold (lambda K (lambda _ (lambda Acc (cons K Acc)))) V2939 ()))

(defun dict-values (V2941) (dict-fold (lambda _ (lambda V (lambda Acc (cons V Acc)))) V2941 ()))

(defun put (V2946 V2947 V2948 V2949) (let Curr (<-dict/or V2949 V2946 (freeze ())) (let Added (shen.set-key-entry-value V2947 V2948 Curr) (let Update (dict-> V2949 V2946 Added) V2948))))

(defun unput (V2953 V2954 V2955) (let Curr (<-dict/or V2955 V2953 (freeze ())) (let Removed (shen.remove-key-entry-value V2954 Curr) (let Update (dict-> V2955 V2953 Removed) V2953))))

(defun get/or (V2960 V2961 V2962 V2963) (let Entry (<-dict/or V2963 V2960 (freeze ())) (let Result (assoc V2961 Entry) (if (empty? Result) (thaw V2962) (tl Result)))))

(defun get (V2967 V2968 V2969) (get/or V2967 V2968 (freeze (simple-error "value not found
")) V2969))

(defun hash (V2972 V2973) (shen.mod (sum (map (lambda X (string->n X)) (explode V2972))) V2973))

(defun shen.mod (V2976 V2977) (shen.modh V2976 (shen.multiples V2976 (cons V2977 ()))))

(defun shen.multiples (V2980 V2981) (cond ((and (cons? V2981) (> (hd V2981) V2980)) (tl V2981)) ((cons? V2981) (shen.multiples V2980 (cons (* 2 (hd V2981)) V2981))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V2986 V2987) (cond ((= 0 V2986) 0) ((= () V2987) V2986) ((and (cons? V2987) (> (hd V2987) V2986)) (if (empty? (tl V2987)) V2986 (shen.modh V2986 (tl V2987)))) ((cons? V2987) (shen.modh (- V2986 (hd V2987)) V2987)) (true (shen.f_error shen.modh))))

(defun sum (V2989) (cond ((= () V2989) 0) ((cons? V2989) (+ (hd V2989) (sum (tl V2989)))) (true (shen.f_error sum))))

(defun head (V2997) (cond ((cons? V2997) (hd V2997)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V3005) (cond ((cons? V3005) (tl V3005)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V3007) (pos V3007 0))

(defun intersection (V3012 V3013) (cond ((= () V3012) ()) ((cons? V3012) (if (element? (hd V3012) V3013) (cons (hd V3012) (intersection (tl V3012) V3013)) (intersection (tl V3012) V3013))) (true (shen.f_error intersection))))

(defun reverse (V3015) (shen.reverse_help V3015 ()))

(defun shen.reverse_help (V3018 V3019) (cond ((= () V3018) V3019) ((cons? V3018) (shen.reverse_help (tl V3018) (cons (hd V3018) V3019))) (true (shen.f_error shen.reverse_help))))

(defun union (V3022 V3023) (cond ((= () V3022) V3023) ((cons? V3022) (if (element? (hd V3022) V3023) (union (tl V3022) V3023) (cons (hd V3022) (union (tl V3022) V3023)))) (true (shen.f_error union))))

(defun y-or-n? (V3025) (let Message (shen.prhush (shen.proc-nl V3025) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V3025))))))))

(defun not (V3027) (if V3027 false true))

(defun subst (V3040 V3041 V3042) (cond ((= V3042 V3041) V3040) ((cons? V3042) (map (lambda W (subst V3040 V3041 W)) V3042)) (true V3042)))

(defun explode (V3044) (shen.explode-h (shen.app V3044 "" shen.a)))

(defun shen.explode-h (V3046) (cond ((= "" V3046) ()) ((shen.+string? V3046) (cons (pos V3046 0) (shen.explode-h (tlstr V3046)))) (true (shen.f_error shen.explode-h))))

(defun cd (V3048) (set *home-directory* (if (= V3048 "") "" (shen.app V3048 "/" shen.a))))

(defun for-each (V3051 V3052) (cond ((= () V3052) true) ((cons? V3052) (let _ (V3051 (hd V3052)) (for-each V3051 (tl V3052)))) (true (shen.f_error for-each))))

(defun fold-right (V3056 V3057 V3058) (cond ((= () V3057) V3058) ((cons? V3057) (V3056 (hd V3057) (fold-right V3056 (tl V3057) V3058))) (true (shen.f_error fold-right))))

(defun fold-left (V3062 V3063 V3064) (cond ((= () V3064) V3063) ((cons? V3064) (fold-left V3062 (V3062 V3063 (hd V3064)) (tl V3064))) (true (shen.f_error fold-left))))

(defun filter (V3067 V3068) (shen.filter-h V3067 () V3068))

(defun shen.filter-h (V3078 V3079 V3080) (cond ((= () V3080) (reverse V3079)) ((and (cons? V3080) (V3078 (hd V3080))) (shen.filter-h V3078 (cons (hd V3080) V3079) (tl V3080))) ((cons? V3080) (shen.filter-h V3078 V3079 (tl V3080))) (true (shen.f_error shen.filter-h))))

(defun map (V3083 V3084) (shen.map-h V3083 V3084 ()))

(defun shen.map-h (V3090 V3091 V3092) (cond ((= () V3091) (reverse V3092)) ((cons? V3091) (shen.map-h V3090 (tl V3091) (cons (V3090 (hd V3091)) V3092))) (true (shen.f_error shen.map-h))))

(defun length (V3094) (shen.length-h V3094 0))

(defun shen.length-h (V3097 V3098) (cond ((= () V3097) V3098) (true (shen.length-h (tl V3097) (+ V3098 1)))))

(defun occurrences (V3110 V3111) (cond ((= V3111 V3110) 1) ((cons? V3111) (+ (occurrences V3110 (hd V3111)) (occurrences V3110 (tl V3111)))) (true 0)))

(defun nth (V3120 V3121) (cond ((and (= 1 V3120) (cons? V3121)) (hd V3121)) ((cons? V3121) (nth (- V3120 1) (tl V3121))) (true (shen.f_error nth))))

(defun integer? (V3123) (and (number? V3123) (let Abs (shen.abs V3123) (shen.integer-test? Abs (shen.magless Abs 1)))))

(defun shen.abs (V3125) (if (> V3125 0) V3125 (- 0 V3125)))

(defun shen.magless (V3128 V3129) (let Nx2 (* V3129 2) (if (> Nx2 V3128) V3129 (shen.magless V3128 Nx2))))

(defun shen.integer-test? (V3135 V3136) (cond ((= 0 V3135) true) ((> 1 V3135) false) (true (let Abs-N (- V3135 V3136) (if (> 0 Abs-N) (integer? V3135) (shen.integer-test? Abs-N V3136))))))

(defun mapcan (V3141 V3142) (cond ((= () V3142) ()) ((cons? V3142) (append (V3141 (hd V3142)) (mapcan V3141 (tl V3142)))) (true (shen.f_error mapcan))))

(defun == (V3154 V3155) (cond ((= V3155 V3154) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V3157) (and (symbol? V3157) (let Val (value/or V3157 (freeze shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V3159) (cond ((= "" V3159) ()) (true (cons (string->n (pos V3159 0)) (shen.string->bytes (tlstr V3159))))))

(defun maxinferences (V3161) (set shen.*maxinferences* V3161))

(defun inferences () (value shen.*infs*))

(defun protect (V3163) V3163)

(defun stoutput () (value *stoutput*))

(defun sterror () (value shen.*sterror*))

(defun string->symbol (V3165) (let Symbol (intern V3165) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V3165 " to a symbol" shen.s))))))

(defun optimise (V3171) (cond ((= + V3171) (set shen.*optimise* true)) ((= - V3171) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V3173) (trap-error (do (external V3173) true) (lambda E false)))

(defun function (V3175) (shen.lookup-func V3175))

(defun shen.lookup-func (V3177) (get/or V3177 shen.lambda-form (freeze (simple-error (shen.app V3177 " has no lambda expansion
" shen.a))) (value *property-vector*)))



