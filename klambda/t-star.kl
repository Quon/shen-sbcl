"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3499 V3500) (let Curry (shen.curry V3499) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3500)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3502) (cond ((and (cons? V3502) (shen.special? (hd V3502))) (cons (hd V3502) (map (lambda Y (shen.curry Y)) (tl V3502)))) ((and (cons? V3502) (and (cons? (tl V3502)) (shen.extraspecial? (hd V3502)))) V3502) ((and (cons? V3502) (and (= type (hd V3502)) (and (cons? (tl V3502)) (and (cons? (tl (tl V3502))) (= () (tl (tl (tl V3502)))))))) (cons type (cons (shen.curry (hd (tl V3502))) (tl (tl V3502))))) ((and (cons? V3502) (and (cons? (tl V3502)) (cons? (tl (tl V3502))))) (shen.curry (cons (cons (hd V3502) (cons (hd (tl V3502)) ())) (tl (tl V3502))))) ((and (cons? V3502) (and (cons? (tl V3502)) (= () (tl (tl V3502))))) (cons (shen.curry (hd V3502)) (cons (shen.curry (hd (tl V3502))) ()))) (true V3502)))

(defun shen.special? (V3504) (element? V3504 (value shen.*special*)))

(defun shen.extraspecial? (V3506) (element? V3506 (value shen.*extraspecial*)))

(defun shen.t* (V3511 V3512 V3513 V3514) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3513) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3513 (freeze (bind Error (shen.errormaxinfs) V3513 V3514))))) (if (= Case false) (let Case (let V3491 (shen.lazyderef V3511 V3513) (if (= fail V3491) (do (shen.incinfs) (cut Throwcontrol V3513 (freeze (shen.prolog-failure V3513 V3514)))) false)) (if (= Case false) (let Case (let V3492 (shen.lazyderef V3511 V3513) (if (cons? V3492) (let X (hd V3492) (let V3493 (shen.lazyderef (tl V3492) V3513) (if (cons? V3493) (let V3494 (shen.lazyderef (hd V3493) V3513) (if (= : V3494) (let V3495 (shen.lazyderef (tl V3493) V3513) (if (cons? V3495) (let A (hd V3495) (let V3496 (shen.lazyderef (tl V3495) V3513) (if (= () V3496) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3513 (freeze (cut Throwcontrol V3513 (freeze (shen.th* X A V3512 V3513 V3514)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3513) (do (shen.incinfs) (shen.show V3511 V3512 V3513 (freeze (bind Datatypes (value shen.*datatypes*) V3513 (freeze (shen.udefs* V3511 V3512 Datatypes V3513 V3514))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3520) (cond ((= + V3520) (set shen.*shen-type-theory-enabled?* true)) ((= - V3520) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3531 V3532) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3538 V3539 V3540 V3541 V3542) (let Case (let V3487 (shen.lazyderef V3540 V3541) (if (cons? V3487) (let D (hd V3487) (do (shen.incinfs) (call (cons D (cons V3538 (cons V3539 ()))) V3541 V3542))) false)) (if (= Case false) (let V3488 (shen.lazyderef V3540 V3541) (if (cons? V3488) (let Ds (tl V3488) (do (shen.incinfs) (shen.udefs* V3538 V3539 Ds V3541 V3542))) false)) Case)))

(defun shen.th* (V3548 V3549 V3550 V3551 V3552) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3548 (cons : (cons V3549 ()))) V3550 V3551 (freeze (fwhen false V3551 V3552)))) (if (= Case false) (let Case (let F (shen.newpv V3551) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3548 V3551)) V3551 (freeze (bind F (shen.sigf (shen.lazyderef V3548 V3551)) V3551 (freeze (call (cons F (cons V3549 ())) V3551 V3552))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3548 V3549 V3551 V3552)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3548 V3549 V3550 V3551 V3552)) (if (= Case false) (let Case (let V3383 (shen.lazyderef V3548 V3551) (if (cons? V3383) (let F (hd V3383) (let V3384 (shen.lazyderef (tl V3383) V3551) (if (= () V3384) (do (shen.incinfs) (shen.th* F (cons --> (cons V3549 ())) V3550 V3551 V3552)) false))) false)) (if (= Case false) (let Case (let V3385 (shen.lazyderef V3548 V3551) (if (cons? V3385) (let F (hd V3385) (let V3386 (shen.lazyderef (tl V3385) V3551) (if (cons? V3386) (let X (hd V3386) (let V3387 (shen.lazyderef (tl V3386) V3551) (if (= () V3387) (let B (shen.newpv V3551) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3549 ()))) V3550 V3551 (freeze (shen.th* X B V3550 V3551 V3552))))) false))) false))) false)) (if (= Case false) (let Case (let V3388 (shen.lazyderef V3548 V3551) (if (cons? V3388) (let V3389 (shen.lazyderef (hd V3388) V3551) (if (= cons V3389) (let V3390 (shen.lazyderef (tl V3388) V3551) (if (cons? V3390) (let X (hd V3390) (let V3391 (shen.lazyderef (tl V3390) V3551) (if (cons? V3391) (let Y (hd V3391) (let V3392 (shen.lazyderef (tl V3391) V3551) (if (= () V3392) (let V3393 (shen.lazyderef V3549 V3551) (if (cons? V3393) (let V3394 (shen.lazyderef (hd V3393) V3551) (if (= list V3394) (let V3395 (shen.lazyderef (tl V3393) V3551) (if (cons? V3395) (let A (hd V3395) (let V3396 (shen.lazyderef (tl V3395) V3551) (if (= () V3396) (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons list (cons A ())) V3550 V3551 V3552)))) (if (shen.pvar? V3396) (do (shen.bindv V3396 () V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons list (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3396 V3551) Result))) false)))) (if (shen.pvar? V3395) (let A (shen.newpv V3551) (do (shen.bindv V3395 (cons A ()) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons list (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3395 V3551) Result)))) false))) (if (shen.pvar? V3394) (do (shen.bindv V3394 list V3551) (let Result (let V3397 (shen.lazyderef (tl V3393) V3551) (if (cons? V3397) (let A (hd V3397) (let V3398 (shen.lazyderef (tl V3397) V3551) (if (= () V3398) (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons list (cons A ())) V3550 V3551 V3552)))) (if (shen.pvar? V3398) (do (shen.bindv V3398 () V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons list (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3398 V3551) Result))) false)))) (if (shen.pvar? V3397) (let A (shen.newpv V3551) (do (shen.bindv V3397 (cons A ()) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons list (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3397 V3551) Result)))) false))) (do (shen.unbindv V3394 V3551) Result))) false))) (if (shen.pvar? V3393) (let A (shen.newpv V3551) (do (shen.bindv V3393 (cons list (cons A ())) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons list (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3393 V3551) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3399 (shen.lazyderef V3548 V3551) (if (cons? V3399) (let V3400 (shen.lazyderef (hd V3399) V3551) (if (= @p V3400) (let V3401 (shen.lazyderef (tl V3399) V3551) (if (cons? V3401) (let X (hd V3401) (let V3402 (shen.lazyderef (tl V3401) V3551) (if (cons? V3402) (let Y (hd V3402) (let V3403 (shen.lazyderef (tl V3402) V3551) (if (= () V3403) (let V3404 (shen.lazyderef V3549 V3551) (if (cons? V3404) (let A (hd V3404) (let V3405 (shen.lazyderef (tl V3404) V3551) (if (cons? V3405) (let V3406 (shen.lazyderef (hd V3405) V3551) (if (= * V3406) (let V3407 (shen.lazyderef (tl V3405) V3551) (if (cons? V3407) (let B (hd V3407) (let V3408 (shen.lazyderef (tl V3407) V3551) (if (= () V3408) (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y B V3550 V3551 V3552)))) (if (shen.pvar? V3408) (do (shen.bindv V3408 () V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y B V3550 V3551 V3552)))) (do (shen.unbindv V3408 V3551) Result))) false)))) (if (shen.pvar? V3407) (let B (shen.newpv V3551) (do (shen.bindv V3407 (cons B ()) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y B V3550 V3551 V3552)))) (do (shen.unbindv V3407 V3551) Result)))) false))) (if (shen.pvar? V3406) (do (shen.bindv V3406 * V3551) (let Result (let V3409 (shen.lazyderef (tl V3405) V3551) (if (cons? V3409) (let B (hd V3409) (let V3410 (shen.lazyderef (tl V3409) V3551) (if (= () V3410) (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y B V3550 V3551 V3552)))) (if (shen.pvar? V3410) (do (shen.bindv V3410 () V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y B V3550 V3551 V3552)))) (do (shen.unbindv V3410 V3551) Result))) false)))) (if (shen.pvar? V3409) (let B (shen.newpv V3551) (do (shen.bindv V3409 (cons B ()) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y B V3550 V3551 V3552)))) (do (shen.unbindv V3409 V3551) Result)))) false))) (do (shen.unbindv V3406 V3551) Result))) false))) (if (shen.pvar? V3405) (let B (shen.newpv V3551) (do (shen.bindv V3405 (cons * (cons B ())) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y B V3550 V3551 V3552)))) (do (shen.unbindv V3405 V3551) Result)))) false)))) (if (shen.pvar? V3404) (let A (shen.newpv V3551) (let B (shen.newpv V3551) (do (shen.bindv V3404 (cons A (cons * (cons B ()))) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y B V3550 V3551 V3552)))) (do (shen.unbindv V3404 V3551) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3411 (shen.lazyderef V3548 V3551) (if (cons? V3411) (let V3412 (shen.lazyderef (hd V3411) V3551) (if (= @v V3412) (let V3413 (shen.lazyderef (tl V3411) V3551) (if (cons? V3413) (let X (hd V3413) (let V3414 (shen.lazyderef (tl V3413) V3551) (if (cons? V3414) (let Y (hd V3414) (let V3415 (shen.lazyderef (tl V3414) V3551) (if (= () V3415) (let V3416 (shen.lazyderef V3549 V3551) (if (cons? V3416) (let V3417 (shen.lazyderef (hd V3416) V3551) (if (= vector V3417) (let V3418 (shen.lazyderef (tl V3416) V3551) (if (cons? V3418) (let A (hd V3418) (let V3419 (shen.lazyderef (tl V3418) V3551) (if (= () V3419) (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons vector (cons A ())) V3550 V3551 V3552)))) (if (shen.pvar? V3419) (do (shen.bindv V3419 () V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons vector (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3419 V3551) Result))) false)))) (if (shen.pvar? V3418) (let A (shen.newpv V3551) (do (shen.bindv V3418 (cons A ()) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons vector (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3418 V3551) Result)))) false))) (if (shen.pvar? V3417) (do (shen.bindv V3417 vector V3551) (let Result (let V3420 (shen.lazyderef (tl V3416) V3551) (if (cons? V3420) (let A (hd V3420) (let V3421 (shen.lazyderef (tl V3420) V3551) (if (= () V3421) (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons vector (cons A ())) V3550 V3551 V3552)))) (if (shen.pvar? V3421) (do (shen.bindv V3421 () V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons vector (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3421 V3551) Result))) false)))) (if (shen.pvar? V3420) (let A (shen.newpv V3551) (do (shen.bindv V3420 (cons A ()) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons vector (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3420 V3551) Result)))) false))) (do (shen.unbindv V3417 V3551) Result))) false))) (if (shen.pvar? V3416) (let A (shen.newpv V3551) (do (shen.bindv V3416 (cons vector (cons A ())) V3551) (let Result (do (shen.incinfs) (shen.th* X A V3550 V3551 (freeze (shen.th* Y (cons vector (cons A ())) V3550 V3551 V3552)))) (do (shen.unbindv V3416 V3551) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3422 (shen.lazyderef V3548 V3551) (if (cons? V3422) (let V3423 (shen.lazyderef (hd V3422) V3551) (if (= @s V3423) (let V3424 (shen.lazyderef (tl V3422) V3551) (if (cons? V3424) (let X (hd V3424) (let V3425 (shen.lazyderef (tl V3424) V3551) (if (cons? V3425) (let Y (hd V3425) (let V3426 (shen.lazyderef (tl V3425) V3551) (if (= () V3426) (let V3427 (shen.lazyderef V3549 V3551) (if (= string V3427) (do (shen.incinfs) (shen.th* X string V3550 V3551 (freeze (shen.th* Y string V3550 V3551 V3552)))) (if (shen.pvar? V3427) (do (shen.bindv V3427 string V3551) (let Result (do (shen.incinfs) (shen.th* X string V3550 V3551 (freeze (shen.th* Y string V3550 V3551 V3552)))) (do (shen.unbindv V3427 V3551) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3428 (shen.lazyderef V3548 V3551) (if (cons? V3428) (let V3429 (shen.lazyderef (hd V3428) V3551) (if (= lambda V3429) (let V3430 (shen.lazyderef (tl V3428) V3551) (if (cons? V3430) (let X (hd V3430) (let V3431 (shen.lazyderef (tl V3430) V3551) (if (cons? V3431) (let Y (hd V3431) (let V3432 (shen.lazyderef (tl V3431) V3551) (if (= () V3432) (let V3433 (shen.lazyderef V3549 V3551) (if (cons? V3433) (let A (hd V3433) (let V3434 (shen.lazyderef (tl V3433) V3551) (if (cons? V3434) (let V3435 (shen.lazyderef (hd V3434) V3551) (if (= --> V3435) (let V3436 (shen.lazyderef (tl V3434) V3551) (if (cons? V3436) (let B (hd V3436) (let V3437 (shen.lazyderef (tl V3436) V3551) (if (= () V3437) (let Z (shen.newpv V3551) (let X&& (shen.newpv V3551) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Y V3551)) V3551 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3550) V3551 V3552)))))))))) (if (shen.pvar? V3437) (do (shen.bindv V3437 () V3551) (let Result (let Z (shen.newpv V3551) (let X&& (shen.newpv V3551) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Y V3551)) V3551 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3550) V3551 V3552)))))))))) (do (shen.unbindv V3437 V3551) Result))) false)))) (if (shen.pvar? V3436) (let B (shen.newpv V3551) (do (shen.bindv V3436 (cons B ()) V3551) (let Result (let Z (shen.newpv V3551) (let X&& (shen.newpv V3551) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Y V3551)) V3551 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3550) V3551 V3552)))))))))) (do (shen.unbindv V3436 V3551) Result)))) false))) (if (shen.pvar? V3435) (do (shen.bindv V3435 --> V3551) (let Result (let V3438 (shen.lazyderef (tl V3434) V3551) (if (cons? V3438) (let B (hd V3438) (let V3439 (shen.lazyderef (tl V3438) V3551) (if (= () V3439) (let Z (shen.newpv V3551) (let X&& (shen.newpv V3551) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Y V3551)) V3551 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3550) V3551 V3552)))))))))) (if (shen.pvar? V3439) (do (shen.bindv V3439 () V3551) (let Result (let Z (shen.newpv V3551) (let X&& (shen.newpv V3551) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Y V3551)) V3551 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3550) V3551 V3552)))))))))) (do (shen.unbindv V3439 V3551) Result))) false)))) (if (shen.pvar? V3438) (let B (shen.newpv V3551) (do (shen.bindv V3438 (cons B ()) V3551) (let Result (let Z (shen.newpv V3551) (let X&& (shen.newpv V3551) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Y V3551)) V3551 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3550) V3551 V3552)))))))))) (do (shen.unbindv V3438 V3551) Result)))) false))) (do (shen.unbindv V3435 V3551) Result))) false))) (if (shen.pvar? V3434) (let B (shen.newpv V3551) (do (shen.bindv V3434 (cons --> (cons B ())) V3551) (let Result (let Z (shen.newpv V3551) (let X&& (shen.newpv V3551) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Y V3551)) V3551 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3550) V3551 V3552)))))))))) (do (shen.unbindv V3434 V3551) Result)))) false)))) (if (shen.pvar? V3433) (let A (shen.newpv V3551) (let B (shen.newpv V3551) (do (shen.bindv V3433 (cons A (cons --> (cons B ()))) V3551) (let Result (let Z (shen.newpv V3551) (let X&& (shen.newpv V3551) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Y V3551)) V3551 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3550) V3551 V3552)))))))))) (do (shen.unbindv V3433 V3551) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3440 (shen.lazyderef V3548 V3551) (if (cons? V3440) (let V3441 (shen.lazyderef (hd V3440) V3551) (if (= let V3441) (let V3442 (shen.lazyderef (tl V3440) V3551) (if (cons? V3442) (let X (hd V3442) (let V3443 (shen.lazyderef (tl V3442) V3551) (if (cons? V3443) (let Y (hd V3443) (let V3444 (shen.lazyderef (tl V3443) V3551) (if (cons? V3444) (let Z (hd V3444) (let V3445 (shen.lazyderef (tl V3444) V3551) (if (= () V3445) (let W (shen.newpv V3551) (let X&& (shen.newpv V3551) (let B (shen.newpv V3551) (do (shen.incinfs) (shen.th* Y B V3550 V3551 (freeze (bind X&& (shen.placeholder) V3551 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3551) (shen.lazyderef X V3551) (shen.lazyderef Z V3551)) V3551 (freeze (shen.th* W V3549 (cons (cons X&& (cons : (cons B ()))) V3550) V3551 V3552))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3446 (shen.lazyderef V3548 V3551) (if (cons? V3446) (let V3447 (shen.lazyderef (hd V3446) V3551) (if (= open V3447) (let V3448 (shen.lazyderef (tl V3446) V3551) (if (cons? V3448) (let FileName (hd V3448) (let V3449 (shen.lazyderef (tl V3448) V3551) (if (cons? V3449) (let Direction3379 (hd V3449) (let V3450 (shen.lazyderef (tl V3449) V3551) (if (= () V3450) (let V3451 (shen.lazyderef V3549 V3551) (if (cons? V3451) (let V3452 (shen.lazyderef (hd V3451) V3551) (if (= stream V3452) (let V3453 (shen.lazyderef (tl V3451) V3551) (if (cons? V3453) (let Direction (hd V3453) (let V3454 (shen.lazyderef (tl V3453) V3551) (if (= () V3454) (do (shen.incinfs) (unify! Direction Direction3379 V3551 (freeze (cut Throwcontrol V3551 (freeze (fwhen (element? (shen.lazyderef Direction V3551) (cons in (cons out ()))) V3551 (freeze (shen.th* FileName string V3550 V3551 V3552)))))))) (if (shen.pvar? V3454) (do (shen.bindv V3454 () V3551) (let Result (do (shen.incinfs) (unify! Direction Direction3379 V3551 (freeze (cut Throwcontrol V3551 (freeze (fwhen (element? (shen.lazyderef Direction V3551) (cons in (cons out ()))) V3551 (freeze (shen.th* FileName string V3550 V3551 V3552)))))))) (do (shen.unbindv V3454 V3551) Result))) false)))) (if (shen.pvar? V3453) (let Direction (shen.newpv V3551) (do (shen.bindv V3453 (cons Direction ()) V3551) (let Result (do (shen.incinfs) (unify! Direction Direction3379 V3551 (freeze (cut Throwcontrol V3551 (freeze (fwhen (element? (shen.lazyderef Direction V3551) (cons in (cons out ()))) V3551 (freeze (shen.th* FileName string V3550 V3551 V3552)))))))) (do (shen.unbindv V3453 V3551) Result)))) false))) (if (shen.pvar? V3452) (do (shen.bindv V3452 stream V3551) (let Result (let V3455 (shen.lazyderef (tl V3451) V3551) (if (cons? V3455) (let Direction (hd V3455) (let V3456 (shen.lazyderef (tl V3455) V3551) (if (= () V3456) (do (shen.incinfs) (unify! Direction Direction3379 V3551 (freeze (cut Throwcontrol V3551 (freeze (fwhen (element? (shen.lazyderef Direction V3551) (cons in (cons out ()))) V3551 (freeze (shen.th* FileName string V3550 V3551 V3552)))))))) (if (shen.pvar? V3456) (do (shen.bindv V3456 () V3551) (let Result (do (shen.incinfs) (unify! Direction Direction3379 V3551 (freeze (cut Throwcontrol V3551 (freeze (fwhen (element? (shen.lazyderef Direction V3551) (cons in (cons out ()))) V3551 (freeze (shen.th* FileName string V3550 V3551 V3552)))))))) (do (shen.unbindv V3456 V3551) Result))) false)))) (if (shen.pvar? V3455) (let Direction (shen.newpv V3551) (do (shen.bindv V3455 (cons Direction ()) V3551) (let Result (do (shen.incinfs) (unify! Direction Direction3379 V3551 (freeze (cut Throwcontrol V3551 (freeze (fwhen (element? (shen.lazyderef Direction V3551) (cons in (cons out ()))) V3551 (freeze (shen.th* FileName string V3550 V3551 V3552)))))))) (do (shen.unbindv V3455 V3551) Result)))) false))) (do (shen.unbindv V3452 V3551) Result))) false))) (if (shen.pvar? V3451) (let Direction (shen.newpv V3551) (do (shen.bindv V3451 (cons stream (cons Direction ())) V3551) (let Result (do (shen.incinfs) (unify! Direction Direction3379 V3551 (freeze (cut Throwcontrol V3551 (freeze (fwhen (element? (shen.lazyderef Direction V3551) (cons in (cons out ()))) V3551 (freeze (shen.th* FileName string V3550 V3551 V3552)))))))) (do (shen.unbindv V3451 V3551) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3457 (shen.lazyderef V3548 V3551) (if (cons? V3457) (let V3458 (shen.lazyderef (hd V3457) V3551) (if (= type V3458) (let V3459 (shen.lazyderef (tl V3457) V3551) (if (cons? V3459) (let X (hd V3459) (let V3460 (shen.lazyderef (tl V3459) V3551) (if (cons? V3460) (let A (hd V3460) (let V3461 (shen.lazyderef (tl V3460) V3551) (if (= () V3461) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (unify A V3549 V3551 (freeze (shen.th* X A V3550 V3551 V3552)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3462 (shen.lazyderef V3548 V3551) (if (cons? V3462) (let V3463 (shen.lazyderef (hd V3462) V3551) (if (= input+ V3463) (let V3464 (shen.lazyderef (tl V3462) V3551) (if (cons? V3464) (let A (hd V3464) (let V3465 (shen.lazyderef (tl V3464) V3551) (if (cons? V3465) (let Stream (hd V3465) (let V3466 (shen.lazyderef (tl V3465) V3551) (if (= () V3466) (let C (shen.newpv V3551) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3551)) V3551 (freeze (unify V3549 C V3551 (freeze (shen.th* Stream (cons stream (cons in ())) V3550 V3551 V3552))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3467 (shen.lazyderef V3548 V3551) (if (cons? V3467) (let V3468 (shen.lazyderef (hd V3467) V3551) (if (= set V3468) (let V3469 (shen.lazyderef (tl V3467) V3551) (if (cons? V3469) (let Var (hd V3469) (let V3470 (shen.lazyderef (tl V3469) V3551) (if (cons? V3470) (let Val (hd V3470) (let V3471 (shen.lazyderef (tl V3470) V3551) (if (= () V3471) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (shen.th* Var symbol V3550 V3551 (freeze (cut Throwcontrol V3551 (freeze (shen.th* (cons value (cons Var ())) V3549 V3550 V3551 (freeze (shen.th* Val V3549 V3550 V3551 V3552)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3551) (do (shen.incinfs) (shen.t*-hyps V3550 NewHyp V3551 (freeze (shen.th* V3548 V3549 NewHyp V3551 V3552))))) (if (= Case false) (let Case (let V3472 (shen.lazyderef V3548 V3551) (if (cons? V3472) (let V3473 (shen.lazyderef (hd V3472) V3551) (if (= define V3473) (let V3474 (shen.lazyderef (tl V3472) V3551) (if (cons? V3474) (let F (hd V3474) (let X (tl V3474) (do (shen.incinfs) (cut Throwcontrol V3551 (freeze (shen.t*-def (cons define (cons F X)) V3549 V3550 V3551 V3552)))))) false)) false)) false)) (if (= Case false) (let Case (let V3475 (shen.lazyderef V3548 V3551) (if (cons? V3475) (let V3476 (shen.lazyderef (hd V3475) V3551) (if (= defmacro V3476) (let V3477 (shen.lazyderef V3549 V3551) (if (= unit V3477) (do (shen.incinfs) (cut Throwcontrol V3551 V3552)) (if (shen.pvar? V3477) (do (shen.bindv V3477 unit V3551) (let Result (do (shen.incinfs) (cut Throwcontrol V3551 V3552)) (do (shen.unbindv V3477 V3551) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3478 (shen.lazyderef V3548 V3551) (if (cons? V3478) (let V3479 (shen.lazyderef (hd V3478) V3551) (if (= shen.process-datatype V3479) (let V3480 (shen.lazyderef V3549 V3551) (if (= symbol V3480) (do (shen.incinfs) (thaw V3552)) (if (shen.pvar? V3480) (do (shen.bindv V3480 symbol V3551) (let Result (do (shen.incinfs) (thaw V3552)) (do (shen.unbindv V3480 V3551) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3481 (shen.lazyderef V3548 V3551) (if (cons? V3481) (let V3482 (shen.lazyderef (hd V3481) V3551) (if (= shen.synonyms-help V3482) (let V3483 (shen.lazyderef V3549 V3551) (if (= symbol V3483) (do (shen.incinfs) (thaw V3552)) (if (shen.pvar? V3483) (do (shen.bindv V3483 symbol V3551) (let Result (do (shen.incinfs) (thaw V3552)) (do (shen.unbindv V3483 V3551) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3551) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3551 (freeze (shen.udefs* (cons V3548 (cons : (cons V3549 ()))) V3550 Datatypes V3551 V3552))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3557 V3558 V3559 V3560) (let Case (let V3294 (shen.lazyderef V3557 V3559) (if (cons? V3294) (let V3295 (shen.lazyderef (hd V3294) V3559) (if (cons? V3295) (let V3296 (shen.lazyderef (hd V3295) V3559) (if (cons? V3296) (let V3297 (shen.lazyderef (hd V3296) V3559) (if (= cons V3297) (let V3298 (shen.lazyderef (tl V3296) V3559) (if (cons? V3298) (let X (hd V3298) (let V3299 (shen.lazyderef (tl V3298) V3559) (if (cons? V3299) (let Y (hd V3299) (let V3300 (shen.lazyderef (tl V3299) V3559) (if (= () V3300) (let V3301 (shen.lazyderef (tl V3295) V3559) (if (cons? V3301) (let V3302 (shen.lazyderef (hd V3301) V3559) (if (= : V3302) (let V3303 (shen.lazyderef (tl V3301) V3559) (if (cons? V3303) (let V3304 (shen.lazyderef (hd V3303) V3559) (if (cons? V3304) (let V3305 (shen.lazyderef (hd V3304) V3559) (if (= list V3305) (let V3306 (shen.lazyderef (tl V3304) V3559) (if (cons? V3306) (let A (hd V3306) (let V3307 (shen.lazyderef (tl V3306) V3559) (if (= () V3307) (let V3308 (shen.lazyderef (tl V3303) V3559) (if (= () V3308) (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3308) (do (shen.bindv V3308 () V3559) (let Result (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3308 V3559) Result))) false))) (if (shen.pvar? V3307) (do (shen.bindv V3307 () V3559) (let Result (let V3309 (shen.lazyderef (tl V3303) V3559) (if (= () V3309) (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3309) (do (shen.bindv V3309 () V3559) (let Result (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3309 V3559) Result))) false))) (do (shen.unbindv V3307 V3559) Result))) false)))) (if (shen.pvar? V3306) (let A (shen.newpv V3559) (do (shen.bindv V3306 (cons A ()) V3559) (let Result (let V3310 (shen.lazyderef (tl V3303) V3559) (if (= () V3310) (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3310) (do (shen.bindv V3310 () V3559) (let Result (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3310 V3559) Result))) false))) (do (shen.unbindv V3306 V3559) Result)))) false))) (if (shen.pvar? V3305) (do (shen.bindv V3305 list V3559) (let Result (let V3311 (shen.lazyderef (tl V3304) V3559) (if (cons? V3311) (let A (hd V3311) (let V3312 (shen.lazyderef (tl V3311) V3559) (if (= () V3312) (let V3313 (shen.lazyderef (tl V3303) V3559) (if (= () V3313) (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3313) (do (shen.bindv V3313 () V3559) (let Result (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3313 V3559) Result))) false))) (if (shen.pvar? V3312) (do (shen.bindv V3312 () V3559) (let Result (let V3314 (shen.lazyderef (tl V3303) V3559) (if (= () V3314) (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3314) (do (shen.bindv V3314 () V3559) (let Result (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3314 V3559) Result))) false))) (do (shen.unbindv V3312 V3559) Result))) false)))) (if (shen.pvar? V3311) (let A (shen.newpv V3559) (do (shen.bindv V3311 (cons A ()) V3559) (let Result (let V3315 (shen.lazyderef (tl V3303) V3559) (if (= () V3315) (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3315) (do (shen.bindv V3315 () V3559) (let Result (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3315 V3559) Result))) false))) (do (shen.unbindv V3311 V3559) Result)))) false))) (do (shen.unbindv V3305 V3559) Result))) false))) (if (shen.pvar? V3304) (let A (shen.newpv V3559) (do (shen.bindv V3304 (cons list (cons A ())) V3559) (let Result (let V3316 (shen.lazyderef (tl V3303) V3559) (if (= () V3316) (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3316) (do (shen.bindv V3316 () V3559) (let Result (let Hyp (tl V3294) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons list (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3316 V3559) Result))) false))) (do (shen.unbindv V3304 V3559) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3317 (shen.lazyderef V3557 V3559) (if (cons? V3317) (let V3318 (shen.lazyderef (hd V3317) V3559) (if (cons? V3318) (let V3319 (shen.lazyderef (hd V3318) V3559) (if (cons? V3319) (let V3320 (shen.lazyderef (hd V3319) V3559) (if (= @p V3320) (let V3321 (shen.lazyderef (tl V3319) V3559) (if (cons? V3321) (let X (hd V3321) (let V3322 (shen.lazyderef (tl V3321) V3559) (if (cons? V3322) (let Y (hd V3322) (let V3323 (shen.lazyderef (tl V3322) V3559) (if (= () V3323) (let V3324 (shen.lazyderef (tl V3318) V3559) (if (cons? V3324) (let V3325 (shen.lazyderef (hd V3324) V3559) (if (= : V3325) (let V3326 (shen.lazyderef (tl V3324) V3559) (if (cons? V3326) (let V3327 (shen.lazyderef (hd V3326) V3559) (if (cons? V3327) (let A (hd V3327) (let V3328 (shen.lazyderef (tl V3327) V3559) (if (cons? V3328) (let V3329 (shen.lazyderef (hd V3328) V3559) (if (= * V3329) (let V3330 (shen.lazyderef (tl V3328) V3559) (if (cons? V3330) (let B (hd V3330) (let V3331 (shen.lazyderef (tl V3330) V3559) (if (= () V3331) (let V3332 (shen.lazyderef (tl V3326) V3559) (if (= () V3332) (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3332) (do (shen.bindv V3332 () V3559) (let Result (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3332 V3559) Result))) false))) (if (shen.pvar? V3331) (do (shen.bindv V3331 () V3559) (let Result (let V3333 (shen.lazyderef (tl V3326) V3559) (if (= () V3333) (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3333) (do (shen.bindv V3333 () V3559) (let Result (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3333 V3559) Result))) false))) (do (shen.unbindv V3331 V3559) Result))) false)))) (if (shen.pvar? V3330) (let B (shen.newpv V3559) (do (shen.bindv V3330 (cons B ()) V3559) (let Result (let V3334 (shen.lazyderef (tl V3326) V3559) (if (= () V3334) (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3334) (do (shen.bindv V3334 () V3559) (let Result (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3334 V3559) Result))) false))) (do (shen.unbindv V3330 V3559) Result)))) false))) (if (shen.pvar? V3329) (do (shen.bindv V3329 * V3559) (let Result (let V3335 (shen.lazyderef (tl V3328) V3559) (if (cons? V3335) (let B (hd V3335) (let V3336 (shen.lazyderef (tl V3335) V3559) (if (= () V3336) (let V3337 (shen.lazyderef (tl V3326) V3559) (if (= () V3337) (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3337) (do (shen.bindv V3337 () V3559) (let Result (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3337 V3559) Result))) false))) (if (shen.pvar? V3336) (do (shen.bindv V3336 () V3559) (let Result (let V3338 (shen.lazyderef (tl V3326) V3559) (if (= () V3338) (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3338) (do (shen.bindv V3338 () V3559) (let Result (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3338 V3559) Result))) false))) (do (shen.unbindv V3336 V3559) Result))) false)))) (if (shen.pvar? V3335) (let B (shen.newpv V3559) (do (shen.bindv V3335 (cons B ()) V3559) (let Result (let V3339 (shen.lazyderef (tl V3326) V3559) (if (= () V3339) (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3339) (do (shen.bindv V3339 () V3559) (let Result (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3339 V3559) Result))) false))) (do (shen.unbindv V3335 V3559) Result)))) false))) (do (shen.unbindv V3329 V3559) Result))) false))) (if (shen.pvar? V3328) (let B (shen.newpv V3559) (do (shen.bindv V3328 (cons * (cons B ())) V3559) (let Result (let V3340 (shen.lazyderef (tl V3326) V3559) (if (= () V3340) (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3340) (do (shen.bindv V3340 () V3559) (let Result (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3340 V3559) Result))) false))) (do (shen.unbindv V3328 V3559) Result)))) false)))) (if (shen.pvar? V3327) (let A (shen.newpv V3559) (let B (shen.newpv V3559) (do (shen.bindv V3327 (cons A (cons * (cons B ()))) V3559) (let Result (let V3341 (shen.lazyderef (tl V3326) V3559) (if (= () V3341) (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3341) (do (shen.bindv V3341 () V3559) (let Result (let Hyp (tl V3317) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (shen.lazyderef B V3559) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3341 V3559) Result))) false))) (do (shen.unbindv V3327 V3559) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3342 (shen.lazyderef V3557 V3559) (if (cons? V3342) (let V3343 (shen.lazyderef (hd V3342) V3559) (if (cons? V3343) (let V3344 (shen.lazyderef (hd V3343) V3559) (if (cons? V3344) (let V3345 (shen.lazyderef (hd V3344) V3559) (if (= @v V3345) (let V3346 (shen.lazyderef (tl V3344) V3559) (if (cons? V3346) (let X (hd V3346) (let V3347 (shen.lazyderef (tl V3346) V3559) (if (cons? V3347) (let Y (hd V3347) (let V3348 (shen.lazyderef (tl V3347) V3559) (if (= () V3348) (let V3349 (shen.lazyderef (tl V3343) V3559) (if (cons? V3349) (let V3350 (shen.lazyderef (hd V3349) V3559) (if (= : V3350) (let V3351 (shen.lazyderef (tl V3349) V3559) (if (cons? V3351) (let V3352 (shen.lazyderef (hd V3351) V3559) (if (cons? V3352) (let V3353 (shen.lazyderef (hd V3352) V3559) (if (= vector V3353) (let V3354 (shen.lazyderef (tl V3352) V3559) (if (cons? V3354) (let A (hd V3354) (let V3355 (shen.lazyderef (tl V3354) V3559) (if (= () V3355) (let V3356 (shen.lazyderef (tl V3351) V3559) (if (= () V3356) (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3356) (do (shen.bindv V3356 () V3559) (let Result (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3356 V3559) Result))) false))) (if (shen.pvar? V3355) (do (shen.bindv V3355 () V3559) (let Result (let V3357 (shen.lazyderef (tl V3351) V3559) (if (= () V3357) (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3357) (do (shen.bindv V3357 () V3559) (let Result (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3357 V3559) Result))) false))) (do (shen.unbindv V3355 V3559) Result))) false)))) (if (shen.pvar? V3354) (let A (shen.newpv V3559) (do (shen.bindv V3354 (cons A ()) V3559) (let Result (let V3358 (shen.lazyderef (tl V3351) V3559) (if (= () V3358) (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3358) (do (shen.bindv V3358 () V3559) (let Result (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3358 V3559) Result))) false))) (do (shen.unbindv V3354 V3559) Result)))) false))) (if (shen.pvar? V3353) (do (shen.bindv V3353 vector V3559) (let Result (let V3359 (shen.lazyderef (tl V3352) V3559) (if (cons? V3359) (let A (hd V3359) (let V3360 (shen.lazyderef (tl V3359) V3559) (if (= () V3360) (let V3361 (shen.lazyderef (tl V3351) V3559) (if (= () V3361) (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3361) (do (shen.bindv V3361 () V3559) (let Result (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3361 V3559) Result))) false))) (if (shen.pvar? V3360) (do (shen.bindv V3360 () V3559) (let Result (let V3362 (shen.lazyderef (tl V3351) V3559) (if (= () V3362) (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3362) (do (shen.bindv V3362 () V3559) (let Result (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3362 V3559) Result))) false))) (do (shen.unbindv V3360 V3559) Result))) false)))) (if (shen.pvar? V3359) (let A (shen.newpv V3559) (do (shen.bindv V3359 (cons A ()) V3559) (let Result (let V3363 (shen.lazyderef (tl V3351) V3559) (if (= () V3363) (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3363) (do (shen.bindv V3363 () V3559) (let Result (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3363 V3559) Result))) false))) (do (shen.unbindv V3359 V3559) Result)))) false))) (do (shen.unbindv V3353 V3559) Result))) false))) (if (shen.pvar? V3352) (let A (shen.newpv V3559) (do (shen.bindv V3352 (cons vector (cons A ())) V3559) (let Result (let V3364 (shen.lazyderef (tl V3351) V3559) (if (= () V3364) (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3364) (do (shen.bindv V3364 () V3559) (let Result (let Hyp (tl V3342) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons (shen.lazyderef A V3559) ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons (cons vector (cons (shen.lazyderef A V3559) ())) ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3364 V3559) Result))) false))) (do (shen.unbindv V3352 V3559) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3365 (shen.lazyderef V3557 V3559) (if (cons? V3365) (let V3366 (shen.lazyderef (hd V3365) V3559) (if (cons? V3366) (let V3367 (shen.lazyderef (hd V3366) V3559) (if (cons? V3367) (let V3368 (shen.lazyderef (hd V3367) V3559) (if (= @s V3368) (let V3369 (shen.lazyderef (tl V3367) V3559) (if (cons? V3369) (let X (hd V3369) (let V3370 (shen.lazyderef (tl V3369) V3559) (if (cons? V3370) (let Y (hd V3370) (let V3371 (shen.lazyderef (tl V3370) V3559) (if (= () V3371) (let V3372 (shen.lazyderef (tl V3366) V3559) (if (cons? V3372) (let V3373 (shen.lazyderef (hd V3372) V3559) (if (= : V3373) (let V3374 (shen.lazyderef (tl V3372) V3559) (if (cons? V3374) (let V3375 (shen.lazyderef (hd V3374) V3559) (if (= string V3375) (let V3376 (shen.lazyderef (tl V3374) V3559) (if (= () V3376) (let Hyp (tl V3365) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons string ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3376) (do (shen.bindv V3376 () V3559) (let Result (let Hyp (tl V3365) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons string ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3376 V3559) Result))) false))) (if (shen.pvar? V3375) (do (shen.bindv V3375 string V3559) (let Result (let V3377 (shen.lazyderef (tl V3374) V3559) (if (= () V3377) (let Hyp (tl V3365) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons string ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (if (shen.pvar? V3377) (do (shen.bindv V3377 () V3559) (let Result (let Hyp (tl V3365) (do (shen.incinfs) (bind V3558 (cons (cons (shen.lazyderef X V3559) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3559) (cons : (cons string ()))) (shen.lazyderef Hyp V3559))) V3559 V3560))) (do (shen.unbindv V3377 V3559) Result))) false))) (do (shen.unbindv V3375 V3559) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3378 (shen.lazyderef V3557 V3559) (if (cons? V3378) (let X (hd V3378) (let Hyp (tl V3378) (let NewHyps (shen.newpv V3559) (do (shen.incinfs) (bind V3558 (cons (shen.lazyderef X V3559) (shen.lazyderef NewHyps V3559)) V3559 (freeze (shen.t*-hyps Hyp NewHyps V3559 V3560))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3577 V3578 V3579 V3580) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3577 V3579)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3578 V3579) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3580))))))))) (true (thaw V3580))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3582) (cond ((and (cons? V3582) (and (cons? (tl V3582)) (and (= : (hd (tl V3582))) (and (cons? (tl (tl V3582))) (= () (tl (tl (tl V3582)))))))) (shen.prhush (shen.app (hd V3582) (cn " : " (shen.app (hd (tl (tl V3582))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3582 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3587 V3588) (cond ((= () V3587) shen.skip) ((cons? V3587) (do (shen.prhush (shen.app V3588 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3587)) (do (nl 1) (shen.show-assumptions (tl V3587) (+ V3588 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3590) (cons? (assoc V3590 (value shen.*signedfuncs*))))

(defun shen.sigf (V3592) (concat shen.type-signature-of- V3592))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3597 V3598 V3599 V3600) (let Case (let V3281 (shen.lazyderef V3598 V3599) (if (= number V3281) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3597 V3599)) V3599 V3600)) (if (shen.pvar? V3281) (do (shen.bindv V3281 number V3599) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3597 V3599)) V3599 V3600)) (do (shen.unbindv V3281 V3599) Result))) false))) (if (= Case false) (let Case (let V3282 (shen.lazyderef V3598 V3599) (if (= boolean V3282) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3597 V3599)) V3599 V3600)) (if (shen.pvar? V3282) (do (shen.bindv V3282 boolean V3599) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3597 V3599)) V3599 V3600)) (do (shen.unbindv V3282 V3599) Result))) false))) (if (= Case false) (let Case (let V3283 (shen.lazyderef V3598 V3599) (if (= string V3283) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3597 V3599)) V3599 V3600)) (if (shen.pvar? V3283) (do (shen.bindv V3283 string V3599) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3597 V3599)) V3599 V3600)) (do (shen.unbindv V3283 V3599) Result))) false))) (if (= Case false) (let Case (let V3284 (shen.lazyderef V3598 V3599) (if (= symbol V3284) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3597 V3599)) V3599 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3597 V3599))) V3599 V3600)))) (if (shen.pvar? V3284) (do (shen.bindv V3284 symbol V3599) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3597 V3599)) V3599 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3597 V3599))) V3599 V3600)))) (do (shen.unbindv V3284 V3599) Result))) false))) (if (= Case false) (let V3285 (shen.lazyderef V3597 V3599) (if (= () V3285) (let V3286 (shen.lazyderef V3598 V3599) (if (cons? V3286) (let V3287 (shen.lazyderef (hd V3286) V3599) (if (= list V3287) (let V3288 (shen.lazyderef (tl V3286) V3599) (if (cons? V3288) (let A (hd V3288) (let V3289 (shen.lazyderef (tl V3288) V3599) (if (= () V3289) (do (shen.incinfs) (thaw V3600)) (if (shen.pvar? V3289) (do (shen.bindv V3289 () V3599) (let Result (do (shen.incinfs) (thaw V3600)) (do (shen.unbindv V3289 V3599) Result))) false)))) (if (shen.pvar? V3288) (let A (shen.newpv V3599) (do (shen.bindv V3288 (cons A ()) V3599) (let Result (do (shen.incinfs) (thaw V3600)) (do (shen.unbindv V3288 V3599) Result)))) false))) (if (shen.pvar? V3287) (do (shen.bindv V3287 list V3599) (let Result (let V3290 (shen.lazyderef (tl V3286) V3599) (if (cons? V3290) (let A (hd V3290) (let V3291 (shen.lazyderef (tl V3290) V3599) (if (= () V3291) (do (shen.incinfs) (thaw V3600)) (if (shen.pvar? V3291) (do (shen.bindv V3291 () V3599) (let Result (do (shen.incinfs) (thaw V3600)) (do (shen.unbindv V3291 V3599) Result))) false)))) (if (shen.pvar? V3290) (let A (shen.newpv V3599) (do (shen.bindv V3290 (cons A ()) V3599) (let Result (do (shen.incinfs) (thaw V3600)) (do (shen.unbindv V3290 V3599) Result)))) false))) (do (shen.unbindv V3287 V3599) Result))) false))) (if (shen.pvar? V3286) (let A (shen.newpv V3599) (do (shen.bindv V3286 (cons list (cons A ())) V3599) (let Result (do (shen.incinfs) (thaw V3600)) (do (shen.unbindv V3286 V3599) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3606 V3607 V3608 V3609 V3610) (let Case (let V3272 (shen.lazyderef V3608 V3609) (if (cons? V3272) (let V3273 (shen.lazyderef (hd V3272) V3609) (if (cons? V3273) (let Y (hd V3273) (let V3274 (shen.lazyderef (tl V3273) V3609) (if (cons? V3274) (let V3275 (shen.lazyderef (hd V3274) V3609) (if (= : V3275) (let V3276 (shen.lazyderef (tl V3274) V3609) (if (cons? V3276) (let B (hd V3276) (let V3277 (shen.lazyderef (tl V3276) V3609) (if (= () V3277) (do (shen.incinfs) (identical V3606 Y V3609 (freeze (unify! V3607 B V3609 V3610)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3278 (shen.lazyderef V3608 V3609) (if (cons? V3278) (let Hyp (tl V3278) (do (shen.incinfs) (shen.by_hypothesis V3606 V3607 Hyp V3609 V3610))) false)) Case)))

(defun shen.t*-def (V3616 V3617 V3618 V3619 V3620) (let V3266 (shen.lazyderef V3616 V3619) (if (cons? V3266) (let V3267 (shen.lazyderef (hd V3266) V3619) (if (= define V3267) (let V3268 (shen.lazyderef (tl V3266) V3619) (if (cons? V3268) (let F (hd V3268) (let X (tl V3268) (let Y (shen.newpv V3619) (let E (shen.newpv V3619) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3617 V3618 V3619 V3620)))))) false)) false)) false)))

(defun shen.t*-defh (V3627 V3628 V3629 V3630 V3631 V3632) (let V3262 (shen.lazyderef V3627 V3631) (if (cons? V3262) (let Sig (hd V3262) (let Rules (tl V3262) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3628 V3629 V3630 Rules V3631 V3632)))) false)))

(defun shen.t*-defhh (V3641 V3642 V3643 V3644 V3645 V3646 V3647 V3648) (do (shen.incinfs) (shen.t*-rules V3646 V3642 1 V3643 (cons (cons V3643 (cons : (cons V3642 ()))) V3645) V3647 (freeze (shen.memo V3643 V3641 V3644 V3647 V3648)))))

(defun shen.memo (V3654 V3655 V3656 V3657 V3658) (let Jnk (shen.newpv V3657) (do (shen.incinfs) (unify! V3656 V3655 V3657 (freeze (bind Jnk (declare (shen.lazyderef V3654 V3657) (shen.lazyderef V3656 V3657)) V3657 V3658))))))

(defun shen.<sig+rules> (V3660) (let Parse_shen.<signature> (shen.<signature> V3660) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3662) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3662) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3662) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3664) (cond ((and (cons? V3664) (and (cons? (tl V3664)) (and (= () (tl (tl V3664))) (= (hd V3664) protect)))) V3664) ((cons? V3664) (map (lambda Z (shen.ue Z)) V3664)) ((variable? V3664) (concat && V3664)) (true V3664)))

(defun shen.ue-sig (V3666) (cond ((cons? V3666) (map (lambda Z (shen.ue-sig Z)) V3666)) ((variable? V3666) (concat &&& V3666)) (true V3666)))

(defun shen.ues (V3672) (cond ((shen.ue? V3672) (cons V3672 ())) ((cons? V3672) (union (shen.ues (hd V3672)) (shen.ues (tl V3672)))) (true ())))

(defun shen.ue? (V3674) (and (symbol? V3674) (shen.ue-h? (str V3674))))

(defun shen.ue-h? (V3682) (cond ((and (shen.+string? V3682) (and (= "&" (pos V3682 0)) (and (shen.+string? (tlstr V3682)) (= "&" (pos (tlstr V3682) 0))))) true) (true false)))

(defun shen.t*-rules (V3690 V3691 V3692 V3693 V3694 V3695 V3696) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3246 (shen.lazyderef V3690 V3695) (if (= () V3246) (do (shen.incinfs) (thaw V3696)) false)) (if (= Case false) (let Case (let V3247 (shen.lazyderef V3690 V3695) (if (cons? V3247) (let Rule (hd V3247) (let Rules (tl V3247) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3691 V3694 V3695 (freeze (cut Throwcontrol V3695 (freeze (shen.t*-rules Rules V3691 (+ V3692 1) V3693 V3694 V3695 V3696)))))))) false)) (if (= Case false) (let Err (shen.newpv V3695) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3692 V3695) (cn " of " (shen.app (shen.lazyderef V3693 V3695) "" shen.a)) shen.a))) V3695 V3696))) Case)) Case)))))

(defun shen.t*-rule (V3702 V3703 V3704 V3705 V3706) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3238 (shen.lazyderef V3702 V3705) (if (cons? V3238) (let Patterns (hd V3238) (let V3239 (shen.lazyderef (tl V3238) V3705) (if (cons? V3239) (let Action (hd V3239) (let V3240 (shen.lazyderef (tl V3239) V3705) (if (= () V3240) (let NewHyps (shen.newpv V3705) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3704 NewHyps V3705 (freeze (shen.t*-patterns Patterns V3703 NewHyps V3705 (freeze (cut Throwcontrol V3705 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3703) (shen.patthyps Patterns V3703 V3704) V3705 V3706))))))))) false))) false))) false)))))

(defun shen.placeholders (V3712) (cond ((shen.ue? V3712) (cons V3712 ())) ((cons? V3712) (union (shen.placeholders (hd V3712)) (shen.placeholders (tl V3712)))) (true ())))

(defun shen.newhyps (V3718 V3719 V3720 V3721 V3722) (let Case (let V3225 (shen.lazyderef V3718 V3721) (if (= () V3225) (do (shen.incinfs) (unify! V3720 V3719 V3721 V3722)) false)) (if (= Case false) (let V3226 (shen.lazyderef V3718 V3721) (if (cons? V3226) (let V3221 (hd V3226) (let Vs (tl V3226) (let V3227 (shen.lazyderef V3720 V3721) (if (cons? V3227) (let V3228 (shen.lazyderef (hd V3227) V3721) (if (cons? V3228) (let V (hd V3228) (let V3229 (shen.lazyderef (tl V3228) V3721) (if (cons? V3229) (let V3230 (shen.lazyderef (hd V3229) V3721) (if (= : V3230) (let V3231 (shen.lazyderef (tl V3229) V3721) (if (cons? V3231) (let A (hd V3231) (let V3232 (shen.lazyderef (tl V3231) V3721) (if (= () V3232) (let NewHyp (tl V3227) (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722))))) (if (shen.pvar? V3232) (do (shen.bindv V3232 () V3721) (let Result (let NewHyp (tl V3227) (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722))))) (do (shen.unbindv V3232 V3721) Result))) false)))) (if (shen.pvar? V3231) (let A (shen.newpv V3721) (do (shen.bindv V3231 (cons A ()) V3721) (let Result (let NewHyp (tl V3227) (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722))))) (do (shen.unbindv V3231 V3721) Result)))) false))) (if (shen.pvar? V3230) (do (shen.bindv V3230 : V3721) (let Result (let V3233 (shen.lazyderef (tl V3229) V3721) (if (cons? V3233) (let A (hd V3233) (let V3234 (shen.lazyderef (tl V3233) V3721) (if (= () V3234) (let NewHyp (tl V3227) (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722))))) (if (shen.pvar? V3234) (do (shen.bindv V3234 () V3721) (let Result (let NewHyp (tl V3227) (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722))))) (do (shen.unbindv V3234 V3721) Result))) false)))) (if (shen.pvar? V3233) (let A (shen.newpv V3721) (do (shen.bindv V3233 (cons A ()) V3721) (let Result (let NewHyp (tl V3227) (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722))))) (do (shen.unbindv V3233 V3721) Result)))) false))) (do (shen.unbindv V3230 V3721) Result))) false))) (if (shen.pvar? V3229) (let A (shen.newpv V3721) (do (shen.bindv V3229 (cons : (cons A ())) V3721) (let Result (let NewHyp (tl V3227) (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722))))) (do (shen.unbindv V3229 V3721) Result)))) false)))) (if (shen.pvar? V3228) (let V (shen.newpv V3721) (let A (shen.newpv V3721) (do (shen.bindv V3228 (cons V (cons : (cons A ()))) V3721) (let Result (let NewHyp (tl V3227) (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722))))) (do (shen.unbindv V3228 V3721) Result))))) false))) (if (shen.pvar? V3227) (let V (shen.newpv V3721) (let A (shen.newpv V3721) (let NewHyp (shen.newpv V3721) (do (shen.bindv V3227 (cons (cons V (cons : (cons A ()))) NewHyp) V3721) (let Result (do (shen.incinfs) (unify! V V3221 V3721 (freeze (shen.newhyps Vs V3719 NewHyp V3721 V3722)))) (do (shen.unbindv V3227 V3721) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3728 V3729 V3730) (cond ((= () V3728) V3730) ((and (cons? V3728) (and (cons? V3729) (and (cons? (tl V3729)) (and (= --> (hd (tl V3729))) (and (cons? (tl (tl V3729))) (= () (tl (tl (tl V3729))))))))) (adjoin (cons (hd V3728) (cons : (cons (hd V3729) ()))) (shen.patthyps (tl V3728) (hd (tl (tl V3729))) V3730))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3737 V3738) (cond ((and (= () V3737) (and (cons? V3738) (and (= --> (hd V3738)) (and (cons? (tl V3738)) (= () (tl (tl V3738))))))) (hd (tl V3738))) ((= () V3737) V3738) ((and (cons? V3737) (and (cons? V3738) (and (cons? (tl V3738)) (and (= --> (hd (tl V3738))) (and (cons? (tl (tl V3738))) (= () (tl (tl (tl V3738))))))))) (shen.result-type (tl V3737) (hd (tl (tl V3738))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3744 V3745 V3746 V3747 V3748) (let Case (let V3213 (shen.lazyderef V3744 V3747) (if (= () V3213) (do (shen.incinfs) (thaw V3748)) false)) (if (= Case false) (let V3214 (shen.lazyderef V3744 V3747) (if (cons? V3214) (let Pattern (hd V3214) (let Patterns (tl V3214) (let V3215 (shen.lazyderef V3745 V3747) (if (cons? V3215) (let A (hd V3215) (let V3216 (shen.lazyderef (tl V3215) V3747) (if (cons? V3216) (let V3217 (shen.lazyderef (hd V3216) V3747) (if (= --> V3217) (let V3218 (shen.lazyderef (tl V3216) V3747) (if (cons? V3218) (let B (hd V3218) (let V3219 (shen.lazyderef (tl V3218) V3747) (if (= () V3219) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3746 V3747 (freeze (shen.t*-patterns Patterns B V3746 V3747 V3748)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3754 V3755 V3756 V3757 V3758) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3190 (shen.lazyderef V3754 V3757) (if (cons? V3190) (let V3191 (shen.lazyderef (hd V3190) V3757) (if (= where V3191) (let V3192 (shen.lazyderef (tl V3190) V3757) (if (cons? V3192) (let P (hd V3192) (let V3193 (shen.lazyderef (tl V3192) V3757) (if (cons? V3193) (let Action (hd V3193) (let V3194 (shen.lazyderef (tl V3193) V3757) (if (= () V3194) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3756 V3757 (freeze (cut Throwcontrol V3757 (freeze (shen.t*-action Action V3755 (cons (cons P (cons : (cons verified ()))) V3756) V3757 V3758)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3195 (shen.lazyderef V3754 V3757) (if (cons? V3195) (let V3196 (shen.lazyderef (hd V3195) V3757) (if (= shen.choicepoint! V3196) (let V3197 (shen.lazyderef (tl V3195) V3757) (if (cons? V3197) (let V3198 (shen.lazyderef (hd V3197) V3757) (if (cons? V3198) (let V3199 (shen.lazyderef (hd V3198) V3757) (if (cons? V3199) (let V3200 (shen.lazyderef (hd V3199) V3757) (if (= fail-if V3200) (let V3201 (shen.lazyderef (tl V3199) V3757) (if (cons? V3201) (let F (hd V3201) (let V3202 (shen.lazyderef (tl V3201) V3757) (if (= () V3202) (let V3203 (shen.lazyderef (tl V3198) V3757) (if (cons? V3203) (let Action (hd V3203) (let V3204 (shen.lazyderef (tl V3203) V3757) (if (= () V3204) (let V3205 (shen.lazyderef (tl V3197) V3757) (if (= () V3205) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3755 V3756 V3757 V3758)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3206 (shen.lazyderef V3754 V3757) (if (cons? V3206) (let V3207 (shen.lazyderef (hd V3206) V3757) (if (= shen.choicepoint! V3207) (let V3208 (shen.lazyderef (tl V3206) V3757) (if (cons? V3208) (let Action (hd V3208) (let V3209 (shen.lazyderef (tl V3208) V3757) (if (= () V3209) (do (shen.incinfs) (cut Throwcontrol V3757 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3755 V3756 V3757 V3758)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3754 (cons : (cons V3755 ()))) V3756 V3757 V3758)) Case)) Case)) Case)))))

(defun findall (V3764 V3765 V3766 V3767 V3768) (let B (shen.newpv V3767) (let A (shen.newpv V3767) (do (shen.incinfs) (bind A (gensym shen.a) V3767 (freeze (bind B (set (shen.lazyderef A V3767) ()) V3767 (freeze (shen.findallhelp V3764 V3765 V3766 A V3767 V3768)))))))))

(defun shen.findallhelp (V3775 V3776 V3777 V3778 V3779 V3780) (let Case (do (shen.incinfs) (call V3776 V3779 (freeze (shen.remember V3778 V3775 V3779 (freeze (fwhen false V3779 V3780)))))) (if (= Case false) (do (shen.incinfs) (bind V3777 (value (shen.lazyderef V3778 V3779)) V3779 V3780)) Case)))

(defun shen.remember (V3785 V3786 V3787 V3788) (let B (shen.newpv V3787) (do (shen.incinfs) (bind B (set (shen.deref V3785 V3787) (cons (shen.deref V3786 V3787) (value (shen.deref V3785 V3787)))) V3787 V3788))))



